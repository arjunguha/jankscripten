\documentclass{book}
\usepackage[T1]{fontenc}
\usepackage{fullpage}
\usepackage{palatino}
\usepackage{hyperref}
\usepackage{verbatim}
\usepackage{xspace}
% \usepackage{natbib}
% \bibliographystyle{abbrvnat}
% \setcitestyle{authoryear}

\newcommand{\system}{\texttt{jankscripten}\xspace}
\newcommand{\notwasm}{\textsc{NotWasm}\xspace}
\newcommand{\jankyscript}{JankyScript\xspace}
\newcommand{\kw}[1]{\textbf{\texttt{#1}}}
\newcommand{\metavar}[1]{\textit{#1}}

\title{\system Guide}

\begin{document}

\maketitle

\tableofcontents

\chapter{Introduction}

\system is a compiler and runtime system that targets WebAssembly and supports
multiple front-end languages:

\begin{itemize}

\item \jankyscript is a language with JavaScript syntax. It supports
higher-order functions and a standard library that is similar to JavaScript.
The compiler translates JankyScript to \notwasm by performing type inference
and closure conversion.

\item \notwasm is an explicitly-typed lower-level language that does not
support higher-order functions. However, it does support:
  
\begin{itemize}

\item Garbage collection: at the moment, a simple mark-and-sweep collector with
a stop-and-copy region for floating point numbers.

\item String values: Worth mentioning, since WebAssembly does not support
strings natively.

\item Any-typed values (a.k.a. type dynamic): a failed downcast crashes the
program with an unrecoverable error (i.e., a WebAssembly trap).

\item Monotonic dynamic objects with prototype inheritance: The fields of these
objects are of type Any, and new fields may be added dynamically. However,
these objects \emph{do not support field deletion}. Field lookup in dynamic
objects is optimized using inline caching.

\item Hash tables and arrays: these store Any-typed values.

\item Explicit closures: Although \notwasm does not support higher-order
functions, it has a representation for closures (i.e., code + environment
pointer) which is designed to fit into Any-typed values.

\item ML-style mutable references

\end{itemize}

\end{itemize}

\jankyscript is \emph{not JavaScript}. It makes several simplifying
assumptions, which it inherits from \notwasm. However, as long as you're
working with ``sane'' JavaScript, e.g., JavaScript generated by a compiler from
a saner programming language, you can use JankyScript. With more effort, you
can instead use \notwasm as an intermediate language for a compiler that
targets WebAssembly.

\section{Prerequisites and Building}

\paragraph{Prerequites}
\system is written in Rust, and uses the Rust WebAssembly toolchain. It depends
on Rust packages that link to \emph{libssl} on Linux, and it relies on the Z3
SMT Solver. Finally, the test suite relies on Node. Follow these steps to
install the prerequisites:

\begin{enumerate}

\item Install the \href{https://rustup.rs/}{Rust toolchain}.
\textbf{We require Rust 1.51.0 (released March 2021).} More recent versions of
Rust changed the ABI of the WebAssembly backend. We will fix this soon.
After installing Rust, run the following commands:

\begin{verbatim}
rustup toolchain add 1.51.0
rustup default 1.51.0
\end{verbatim}

\item Install \href{https://nodejs.org/en/}{Node}. We require Node 11 or higher.

\item Install the Rust WebAssembly toolchain:

\begin{verbatim}
rustup target add wasm32-unknown-unknown
\end{verbatim}

\item Install the Wasm-Bindgen CLI, to allow Rust unit tests to run in WebAssembly:

\begin{verbatim}
cargo install wasm-bindgen-cli --version 0.2.69
\end{verbatim}

\item On Ubuntu Linux, install \emph{libssl} and \emph{pkg-config}:

\begin{verbatim}
sudo apt-get install libssl-dev pkg-config
\end{verbatim}

\item Install the Z3 library. On Ubuntu Linux:

\begin{verbatim}
sudo apt-get install libz3-dev
\end{verbatim}

\end{enumerate}

\paragraph{Building}

\begin{enumerate}

\item Build the \system compiler:
\begin{verbatim}
cargo build
\end{verbatim}

\item Build the \system runtime\footnote{This is a separate step because it
targets WebAssembly and not native code}:
\begin{verbatim}
(cd runtime && cargo build)
\end{verbatim}

\item Build the integration testing tool:
\begin{verbatim}
(cd integration_tests && npm install)
\end{verbatim}

\end{enumerate}

\paragraph{Testing}

\begin{verbatim}
cargo test
(cd runtime && cargo test) # Runs tests using WebAssembly
(cd integration_tests && npx jest)
\end{verbatim}

\section{Running}
    
To compile \texttt{filename.ext} to WebAssembly:

\begin{verbatim}
./bin/jankscripten compile filename.ext
\end{verbatim}

\textbf{NOTE:} The supported extensions are .js and .notwasm.

To run a compiled WebAssembly program with the jankscripten runtime:

\begin{verbatim}
./bin/run-node filename.wasm
\end{verbatim}

\section{Debugging}

To debug or profile a compiled WebAssembly program:

\begin{verbatim}
node --inspect-brk bin/run FILENAME.wasm
\end{verbatim}

The Chrome debugger uses source maps correctly to show the original Rust code.
You can use Visual Studio Code or Edge, but source maps do not appear to work
correctly. See the
\href{https://nodejs.org/en/docs/guides/debugging-getting-started/}{Node
Debugging Guide} for more information.

\chapter{\notwasm Guide}

\notwasm is a somewhat low-level language that compiles to WebAssembly. It
supports several data structures that WebAssembly does not natively support. It
also supports garbage collection (presently, a simple mark-and-sweep collector).
\notwasm programs are linked to a runtime system, which is written in Rust
and compiled to WebAssembly.

\notwasm programs use the following concrete syntax for types:

\begin{tabular}{rcll}
\textbf{Result Types} \\
\metavar{R} & := & T 
            & \textrm{Result of type T} \\
            & |  & \kw{void}
            & \textrm{No result} \\
\textbf{Types} \\
\metavar{T} & := & \kw{any} 
         & Unknown type (occupies 64-bits) \\
    & |  & \kw{i32} 
         & A signed, 32-bit integer \\
    & |  & \kw{f64} 
         & A 64-bit float \\
    & |  & \kw{bool} 
         & A boolean \\
    & |  & \kw{str} 
         & A pointer to an immutable string \\
    & |  & \kw{Array}
         & A pointer to an array of any-typed values \\
    & |  & \kw{DynObject} 
         & A pointer to an object with a dynamic set of any-typed fields \\
    & |  & \kw{HT}
         & A pointer to a hash table with string keys and any-typed values \\
    & |  & \kw{(} \metavar{T} \kw{,...,} \metavar{T}\kw{) ->} \metavar{R}
         & A pointer to a function \\
    & |  & \kw{clos (} \metavar{T} \kw{,...,} \metavar{T}\kw{) ->} \metavar{R}
         & A pointer to a closure \\
    & |  & \kw{Ref(}T\kw{)}
         & A pointer to a heap-allocated value of type \metavar{T} \\
    & |  & \kw{env}
         & A pointer to an environment \\
\end{tabular}

\notwasm programs use a psuedo-ANF: \emph{atoms} do no not alter control-flow
or allocate memory, \emph{expressions} may allocate memory but do not alter
control-flow, and \emph{statements} function bodies that may alter the
control-flow of the program.

\paragraph{Primitives} Programs may reference primitive operations that are
defined in the \notwasm runtime system. These operations are imported at the
top of \texttt{stdlib.notwasm}, which is in the root of the repository.

\paragraph{Atoms}
Atoms use the following concrete syntax:

\begin{tabular}{rcll}
\metavar{bop} & := & \kw{+}   & Integer addition \\
              & |  & \kw{-}   & Integer subtraction \\
              & |  & \kw{*}   & Integer multiplication \\
              & |  & \kw{>}   & Integer greater-than comparison \\
              & |  & \kw{<}   & Integer less-than comparison \\
              & |  & \kw{>=}  & Integer greater-than-or-equal-to comparison \\
              & |  & \kw{<=}  & Integer less-than-or-equal-to comparison \\
              & |  & \kw{==}  & Integer equal-to comparison \\
              & |  & \kw{===} & Pointer equality comparison \\
              & |  & \kw{+.}  & Floating-point addition \\
              & |  & \kw{-.}  & Floating-point subtraction \\
              & |  & \kw{*.}  & Floating-point multiplication \\
              & |  & \kw{/.}  & Floating-point division \\
\metavar{b}   & := & \kw{true} | \kw{false} & Boolean literal \\
\metavar{n}   & := & ... & Integer literals \\
\metavar{f}   & := & ... & Floating point literals \\
\metavar{s}   & := & \texttt{"..."} & String literals \\
\metavar{a}   & := & \metavar{b} \\
              & |  & \metavar{n} \\
              & |  & \metavar{f} \\
              & |  & \metavar{s} \\
              & |  & \kw{null} & The null value (has type \kw{any}) \\
              & |  & \metavar{x} & Bound identifier \\
              & |  & \kw{@} \metavar{prim}\textsubscript{a}\kw{(} a\textsubscript{1} ... a\textsubscript{n}\kw{)}
                   & Application of a primitive function that does not allocate memory \\ 
              & |  & \kw{*}\metavar{a}{:}\kw{T}
                   & Pointer dereference \\
              & |  & \metavar{a}\textsubscript{1}\kw{.}\metavar{s}
                   & Read a field of a \kw{DynObject} \\
              & |  & \metavar{a}\textsubscript{1} \metavar{bop} \metavar{a}\textsubscript{2}
                   & Apply a binary operator that does not allocate memory
\end{tabular}

\paragraph{Expresssions}
Expressions have the following concrete syntax:

\begin{tabular}{rcll}
\metavar{e} & := & \metavar{a} 
                 & Atom \\
            & |  & \kw{!} \metavar{prim}\textsubscript{e}\kw{(} x\textsubscript{1} ... x\textsubscript{n}\kw{)}            
                 & Application of a primitive function that may allocate memory \\
            & |  & \metavar{x}\textsubscript{f}\kw{(} x\textsubscript{1} ... x\textsubscript{n}\kw{)}
                 & Function application \\
            & |  & \metavar{x}\textsubscript{f}\kw{!(} \metavar{x}\textsubscript{e}\kw{,}x\textsubscript{1} ... x\textsubscript{n}\kw{)}
                 & Closure application \\
            & |  & \metavar{a}\kw{.}\metavar{x} \kw{=} \metavar{a}
                 & \textrm{Update a field of a DynObject} \\
\end{tabular}

\paragraph{Statements}
Statements have the following concrete syntax:

\begin{tabular}{rcll}
\metavar{blk} & := & \kw{\{} \metavar{s}\textsubscript{1} ... \metavar{s}\textsubscript{n}\kw{\}} \\
\metavar{s} & := & \kw{var} \metavar{x}\kw{:}\metavar{T}\kw{=} \metavar{e}\kw{;}
                 & \textrm{Declare a variable of type \metavar{T}} \\
            & |  & \metavar{x} \kw{=} \metavar{e}\kw{;}
                 & \textrm{Assign a value to a variable} \\
            & |  & \kw{if (}\metavar{a} \kw{)} \metavar{blk} \kw{else} \metavar{blk}
                 & \textrm{Conditional} \\
            & |  & \kw{loop} \metavar{blk}
                 & \textrm{Loop} \\
            & |  & \kw{return} \metavar{a}\kw{;}
                 & \textrm{Return a value} \\
            & |  & \kw{break} \metavar{l}\kw{;}
                 & \textrm{Break out of a block} \\
            & |  & \kw{*}\metavar{x}\kw{=} \metavar{e}\kw{;}
                 & \textrm{Update a local variable} \\
\end{tabular}

\paragraph{Programs}
A program is a list of global variables, followed by a list of functions.
Global variables have the following concrete syntax:

\begin{tabular}{l}
\kw{var} \metavar{x}\kw{:}\metavar{T}\kw{=} \metavar{a}\kw{;} 
\end{tabular}

Functions have the following concrete syntax:

\begin{tabular}{l}
\kw{function} \metavar{x}\textsubscript{f}\kw{(} 
\metavar{x}\textsubscript{1}\kw{:}\metavar{T}\textsubscript{1} ... \metavar{x}\textsubscript{n}\kw{:}\metavar{T}\textsubscript{n}\kw{):}\metavar{R}\kw{ }\metavar{blk}
\end{tabular}

There \emph{must} be a function called \texttt{main} that received no arguments
and does not return a result.

\end{document}