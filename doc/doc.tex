\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage{fullpage}
\usepackage{palatino}
\usepackage{hyperref}
\usepackage{verbatim}
\usepackage{xspace}
% \usepackage{natbib}
% \bibliographystyle{abbrvnat}
% \setcitestyle{authoryear}

\newcommand{\system}{\texttt{jankscripten}\xspace}
\newcommand{\notwasm}{\textsc{NotWasm}\xspace}
\newcommand{\jankyscript}{JankyScript\xspace}
\newcommand{\kw}[1]{\textbf{\texttt{#1}}}
\newcommand{\metavar}[1]{\textit{#1}}

\title{\system Guide}

\begin{document}

\maketitle

\tableofcontents

\section{Introduction}

\system is a compiler and runtime system that targets WebAssembly and supports
multiple front-end languages:

\begin{itemize}

\item \jankyscript is a language with JavaScript syntax. It supports
higher-order functions and a standard library that is similar to JavaScript.
The compiler translates JankyScript to \notwasm by performing type inference
and closure conversion.

\item \notwasm is an explicitly-typed lower-level language that does not
support higher-order functions. However, it does support:
  
\begin{itemize}

\item Garbage collection: at the moment, a simple mark-and-sweep collector with
a stop-and-copy region for floating point numbers.

\item String values: Worth mentioning, since WebAssembly does not support
strings natively.

\item Any-typed values (a.k.a. type dynamic): a failed downcast crashes the
program with an unrecoverable error (i.e., a WebAssembly trap).

\item Monotonic dynamic objects with prototype inheritance: The fields of these
objects are of type Any, and new fields may be added dynamically. However,
these objects \emph{do not support field deletion}. Field lookup in dynamic
objects is optimized using inline caching.

\item Hash tables and arrays: these store Any-typed values.

\item Explicit closures: Although \notwasm does not support higher-order
functions, it has a representation for closures (i.e., code + environment
pointer) which is designed to fit into Any-typed values.

\item ML-style mutable references

\end{itemize}

\end{itemize}

\jankyscript is \emph{not JavaScript}. It makes several simplifying
assumptions, which it inherits from \notwasm. However, as long as you're
working with ``sane'' JavaScript, e.g., JavaScript generated by a compiler from
a saner programming language, you can use JankyScript. With more effort, you
can instead use \notwasm as an intermediate language for a compiler that
targets WebAssembly.

\section{Prerequisites and Building}

\paragraph{Prerequites}
\system is written in Rust, and uses the Rust WebAssembly toolchain. It depends
on Rust packages that link to \emph{libssl} on Linux, and it relies on the Z3
SMT Solver. Finally, the test suite relies on Node. Follow these steps to
install the prerequisites:

\begin{enumerate}

\item Install the \href{https://rustup.rs/}{Rust toolchain}.
\textbf{We require Rust 1.51.0 (released March 2021).} More recent versions of
Rust changed the ABI of the WebAssembly backend. We will fix this soon.
After installing Rust, run the following commands:

\begin{verbatim}
rustup toolchain add 1.51.0
rustup default 1.51.0
\end{verbatim}

\item Install \href{https://nodejs.org/en/}{Node}. We require Node 11 or higher.

\item Install the Rust WebAssembly toolchain:

\begin{verbatim}
rustup target add wasm32-unknown-unknown
\end{verbatim}

\item Install the Wasm-Bindgen CLI, to allow Rust unit tests to run in WebAssembly:

\begin{verbatim}
cargo install wasm-bindgen-cli
\end{verbatim}

\item On Ubuntu Linux, install \emph{libssl} and \emph{pkg-config}:

\begin{verbatim}
sudo apt-get install libssl-dev pkg-config
\end{verbatim}

\item Install the Z3 library. On Ubuntu Linux:

\begin{verbatim}
sudo apt-get install libz3-dev
\end{verbatim}

\end{enumerate}

\paragraph{Building}

\begin{enumerate}

\item Build the \system compiler:
\begin{verbatim}
cargo build
\end{verbatim}

\item Build the \system runtime\footnote{This is a separate step because it
targets WebAssembly and not native code}:
\begin{verbatim}
(cd runtime && cargo build)
\end{verbatim}

\item Build the integration testing tool:
\begin{verbatim}
(cd integration_tests && npm install)
\end{verbatim}

\end{enumerate}

\paragraph{Testing}

\begin{verbatim}
cargo test
(cd runtime && cargo test) # Runs tests using WebAssembly
(cd integration_tests && npx jest)
\end{verbatim}

\section{Running}
    
To compile \texttt{filename.ext} to WebAssembly:

\begin{verbatim}
./bin/jankscripten compile filename.ext
\end{verbatim}

\textbf{NOTE:} The supported extensions are .js and .notwasm.

To run a compiled WebAssembly program with the jankscripten runtime:

\begin{verbatim}
./bin/run-node filename.wasm
\end{verbatim}

\section{Debugging}

To debug or profile a compiled WebAssembly program:

\begin{verbatim}
node --inspect-brk bin/run FILENAME.wasm
\end{verbatim}

The Chrome debugger uses source maps correctly to show the original Rust code.
You can use Visual Studio Code or Edge, but source maps do not appear to work
correctly. See the
\href{https://nodejs.org/en/docs/guides/debugging-getting-started/}{Node
Debugging Guide} for more information.

\section{\notwasm Guide}

\notwasm programs use the following concrete syntax:

\begin{tabular}{rcll}
\textbf{Types} \\
\metavar{T} & := & \kw{any} & Unknown type \\
    & |  & \kw{i32} & Signed, 32-bit integer \\
    & |  & \kw{f64} & 64-bit float \\
    & |  & \kw{bool} & Boolean \\
    & |  & \kw{str} & Pointer to an immutable string \\
    & |  & \kw{Array} & A pointer to an array of any-typed values \\
    & |  & \kw{DynObject} & A pointer to an object with a dynamic set of any-typed fields \\
    & |  & \kw{(} \metavar{T} \kw{,...,} \metavar{T}\kw{) ->} \metavar{T}
         & A pointer to a function \\
    & |  & \kw{(} \metavar{T} \kw{,...,} \metavar{T}\kw{) -> void} 
         & A pointer to a function that does not return a value \\
    & |  & TODO: more to document \\
\metavar{b} & := & \kw{true} | \kw{false} & Boolean literal \\
\metavar{n} & := & ... | $-1$ | 0 | 1 | ... & Integer literals \\
\metavar{s} & := & \texttt{"..."} & String literals \\
\metavar{c} & := & b | n | s & Literals \\
\metavar{e} & := & \textit{x}  & Bound identifier \\
            & |  & \metavar{c} & Literal \\
            & |  & e \kw{:} T  & Type ascription \\
            & |  & \kw{(} \metavar{e} \kw{)} & Parenthesis \\
            & |  & \kw{fun} \metavar{x} \kw{.} \metavar{e} & Function \\
            & |  & \metavar{e}\textsubscript{1} \metavar{e}\textsubscript{2}
                    & Application \\
            & |  & \metavar{e}\textsubscript{1} \kw{+} \metavar{e}\textsubscript{2}
                    & Addition \\
            & |  & \metavar{e}\textsubscript{1} \kw{*} \metavar{e}\textsubscript{2}
                    & Multiplication \\
            & |  & \metavar{e}\textsubscript{1} \kw{=} \metavar{e}\textsubscript{2}
                    & Integer equality \\
            & |  & \metavar{e}\textsubscript{1} \kw{+?} \metavar{e}\textsubscript{2}
                    & Addition or string concatenation (overloaded) \\
            & |  & \kw{(}\metavar{e}\textsubscript{1}\kw{,}\metavar{e}\textsubscript{2}\kw{)}
                    & Pair \\
            & |  & \kw{fix} \metavar{f} \kw{.}\metavar{e}
                    & Fixpoint \\
            & |  & \kw{if} \metavar{e}\textsubscript{1} \kw{then} \metavar{e}\textsubscript{2} \kw{else} \metavar{e}\textsubscript{3}
                    & Conditional \\
            & |  & \kw{let} \metavar{x} \kw{=} \metavar{e}\textsubscript{1} \kw{in} \metavar{e}\textsubscript{2}
                    & Let binding \\
            & |  & \kw{let rec} \metavar{x} \kw{=} \metavar{e}\textsubscript{1} \kw{in} \metavar{e}\textsubscript{2}
                    & Recursive let binding \\

\end{tabular}

\end{document}