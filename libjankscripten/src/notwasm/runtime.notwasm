// Lazily-initialized global variables. DO NOT READ FROM THESE UNTIL THEY HAVE
// BEEN WRITTEN TO.
var Object: DynObject;
var Math: DynObject;
var global: DynObject;
var console: DynObject;
var undefined: any;
// (_, _this, what) -> i32 or f64(NaN)
var parseInt: clos(env, any, any) -> any;
// temporary Error ground to see other compile-time errors (unrelated to this
// being called Error)
var Error: clos(env, any, any) -> any;
// REAL one:
// var Error: clos(env, any, str) -> DynObject;

// source: firefox console -> Math.PI
const __JNKS_PI: f64 = 3.141592653589793f;

// Cached Object properties to be used in jnks_new_object.
// ASSUMPTION: Object.prototype is never modified by user code.
var jnks_objectCreate: clos(env, any) -> any;
var jnks_objectPrototype: any;

// Initialize JankScripten runtime.
function jnks_init() {
    // Create the Object class. This means creating a (really) empty object,
    // giving it a prototype, and assigning its static methods, such as
    // Object.create.
    // 
    // Once the default Object class is set up, object literals like `{}` can
    // be used.

    // load the Object.create runtime function
    var objectCreateF = rt(object_create);
    // comma is obligatory to indicate an empty environment
    var objectCreate = clos(objectCreateF, );

    // create the actual object for Object
    var nullVar = null;
    var objectClass = objectCreate!(nullVar);
    Object = objectClass as DynObject;

    // set a completely empty prototype
    var objectPrototype = objectCreate!(nullVar);
    Object.prototype = objectPrototype;

    // assign static methods to Object
    Object.create = any(objectCreate);

    // Cache Object properties for jnks_new_object
    jnks_objectCreate = objectCreate;
    jnks_objectPrototype = objectPrototype;

    Math = {};
    var mathSqrtF = rt(math_sqrt);
    var mathSqrt = clos(mathSqrtF, );
    Math.sqrt = any(mathSqrt);
    var mathSinF = rt(math_sin);
    var mathSin = clos(mathSinF, );
    Math.sin = any(mathSin);
    var mathAbsF = rt(math_abs);
    var mathAbs = clos(mathAbsF, );
    Math.abs = any(mathAbs);
    var mathMinF = rt(math_min);
    var mathMin = clos(mathMinF, );
    Math.min = any(mathMin);
    var mathMaxF = rt(math_max);
    var mathMax = clos(mathMaxF, );
    Math.max = any(mathMax);
    Math.PI = any(__JNKS_PI);

    console = {};
    var consoleLogF = rt(console_log);
    var consoleLog = clos(consoleLogF, );
    console.log = any(consoleLog);

    // === free-floating stuff in the global namespace ===

    var parseIntF = rt(parse_int);
    parseInt = clos(parseIntF, );

    Error = clos(error_ground, );

    var getUndefined = rt(get_undefined);
    undefined = getUndefined();

    // Now that the default Object class has been set up, create the global 
    // object.
    global = {};
}

// Runtime function to create a regular empty object like `{}` or
// `new Object()`.
function jnks_new_object(): DynObject {
    // Create new object that inherits from Object.prototype.
    var objectCreate = jnks_objectCreate;
    var newObject = objectCreate!(jnks_objectPrototype);
    return newObject as DynObject;
}

function error_raw(_: env, _this: any, message: str): DynObject {
    // `Error("err")` has same functionality as `new Error("err")`
    // so Error i guess doesn't use `this`
    var e_proto = {};
    e_proto.name = any("Error");
    e_proto.message = any(message);
    var e_proto_any = any(e_proto);
    var e = jnks_objectCreate!(e_proto_any);
    return e as DynObject;
}
// there's no reason Error has to be ground. it's top-level, not stored
// in an object, so it's never boxed into any. however, coercion_insertion
// wants to convert it to an object because i'm still waiting to add Mark's
// function-objects, so it needs to be any'd to create a bad coercion so i
// can see other compile-time errors
function error_ground(dummyEnv: env, this: any, message: any): any {
    var messageStr = message as str;
    var result = error_raw(dummyEnv, this, messageStr);
    return any(result);
}
