// Lazily-initialized global variables. DO NOT READ FROM THESE UNTIL THEY HAVE
// BEEN WRITTEN TO.
var Object: DynObject;
var Math: DynObject;
var global: DynObject;
var console: DynObject;
var __JNKS: DynObject;
var undefined: any;
// (_, _this, what) -> i32 or f64(NaN)
var parseInt: clos(env, any, any) -> any;
// temporary Error ground to see other compile-time errors (unrelated to this
// being called Error)
var Error: clos(env, any, any) -> any;
// REAL one:
// var Error: clos(env, any, str) -> DynObject;

// source: firefox console -> Math.PI
const __JNKS_PI: f64 = 3.141592653589793f;

// abusing lazy globals to create a null DynObject for jnks_new_object
var jnks_null_dynobject: DynObject;

// Cached Object properties to be used in jnks_new_object.
// ASSUMPTION: Object.prototype is never modified by user code.
var jnks_objectCreate: clos(env, any) -> any;
// this is needed for an awful check in jnks_new_object, explained there
// the type is bool, but notwasm sucks and can't compare bools, so here we are
var jnks_objectCreateExists: i32 = 0;
var jnks_objectPrototype: any;

// Other cached runtime functions
var jnks_any_is_object: (any) -> bool;
var jnks_primitive_plus: (any, any) -> any;

// Initialize JankScripten runtime.
function jnks_init() {
    // Create the Object class. This means creating a (really) empty object,
    // giving it a prototype, and assigning its static methods, such as
    // Object.create.
    // 
    // Once the default Object class is set up, object literals like `{}` can
    // be used.

    // load the Object.create runtime function
    var objectCreateF = rt(object_create);
    // comma is obligatory to indicate an empty environment
    var objectCreate = clos(objectCreateF, );
    jnks_objectCreate = objectCreate;
    jnks_objectCreateExists = 1;

    // create the actual object for Object
    var nullVar = null;
    var objectClass = objectCreate!(nullVar);
    Object = objectClass as DynObject;

    // set a completely empty prototype.
    // it's called objectPrototypeAny because its type is any.
    var objectPrototypeAny = objectCreate!(nullVar);
    Object.prototype = objectPrototypeAny;

    // assign static methods to Object
    Object.create = any(objectCreate);

    // Cache Object properties for jnks_new_object
    jnks_objectPrototype = objectPrototypeAny;

    // assign methods to Object.prototype.
    // first, unwrap objectPrototypeAny into a DynObject
    var objectPrototype = objectPrototypeAny as DynObject;
    var objectToStringF = jnks_Object_prototype_toString;
    var objectToString = clos(objectToStringF, );
    objectPrototype.toString = any(objectToString);

    Math = {};
    var mathSqrtF = rt(math_sqrt);
    var mathSqrt = clos(mathSqrtF, );
    Math.sqrt = any(mathSqrt);
    var mathSinF = rt(math_sin);
    var mathSin = clos(mathSinF, );
    Math.sin = any(mathSin);
    var mathAbsF = rt(math_abs);
    var mathAbs = clos(mathAbsF, );
    Math.abs = any(mathAbs);
    var mathMinF = rt(math_min);
    var mathMin = clos(mathMinF, );
    Math.min = any(mathMin);
    var mathMaxF = rt(math_max);
    var mathMax = clos(mathMaxF, );
    Math.max = any(mathMax);
    Math.PI = any(__JNKS_PI);

    // __JNKS
    __JNKS = {};
    var heapDumpF = rt(heap_dump);
    var heapDump = clos(heapDumpF, );
    __JNKS.heap_dump = any(heapDump);

    // Other cached runtime functions
    var primitive_plusF = rt(janky_primitive_plus);
    // var primitive_plus = clos(primitive_plusF, );
    jnks_primitive_plus = primitive_plusF;
    var any_is_objectF = rt(any_is_object);
    // var any_is_object = clos(any_is_objectF, );
    jnks_any_is_object = any_is_objectF;

    console = {};
    var consoleLogF = rt(console_log);
    var consoleLog = clos(consoleLogF, );
    console.log = any(consoleLog);
    console.info = any(consoleLog);

    // === free-floating stuff in the global namespace ===

    var parseIntF = rt(parse_int);
    parseInt = clos(parseIntF, );

    Error = clos(error_ground, );

    var getUndefined = rt(get_undefined);
    undefined = getUndefined();

    // Now that the default Object class has been set up, create the global 
    // object.
    global = {};
}

// Runtime function to create a regular empty object like `{}` or
// `new Object()`.
function jnks_new_object(): DynObject {
    var objectCreate = jnks_objectCreate;
    var newObject = objectCreate!(jnks_objectPrototype);
    return newObject as DynObject;
}

function error_raw(_: env, _this: any, message: str): DynObject {
    // `Error("err")` has same functionality as `new Error("err")`
    // so Error i guess doesn't use `this`
    var e_proto = {};
    e_proto.name = any("Error");
    e_proto.message = any(message);
    var e_proto_any = any(e_proto);
    var e = jnks_objectCreate!(e_proto_any);
    return e as DynObject;
}
// there's no reason Error has to be ground. it's top-level, not stored
// in an object, so it's never boxed into any. however, coercion_insertion
// wants to convert it to an object because i'm still waiting to add Mark's
// function-objects, so it needs to be any'd to create a bad coercion so i
// can see other compile-time errors
function error_ground(dummyEnv: env, this: any, message: any): any {
    var messageStr = message as str;
    var result = error_raw(dummyEnv, this, messageStr);
    return any(result);
}

// Create an empty object to be used as a function object.
// The only current difference between this function and jnks_new_object
// is that a `prototype` field is automatically initialized here.
function jnks_new_fn_obj(): DynObject {
    // Create new object that inherits from Object.prototype,
    // AND has a `prototype` field automatically initialized.

    // a new fn object is created to store in the closure of... you guessed it,
    // objectCreate. so we need to give a fake object for that closure
    // only. this hopefully won't be necessary after we optimize non-object
    // functions.

    if (jnks_objectCreateExists == 1) {
        var newObject = jnks_new_object();
        var newObjectProto = jnks_new_object();
        newObject.prototype = any(newObjectProto);
        return newObject;
    } else {}
    // not written as an if-else because wasm typechecking strictness
    // this thing may or may not even be null. it doesn't really matter
    return jnks_null_dynobject;

}

function jnks_Object_prototype_toString(_: env, this: any): any { // TODO: get rid of env parameter
    return any("[object Object]"); // TODO: get rid of the any, it prevents
    // compilation with a useless error message
}

function to_primitive(val: any): any {
    // load cached function into a local variable because notwasm doesn't
    // support directly calling functions stored in global variables.
    var is_object = jnks_any_is_object;
    var is_val_obj = is_object(val);
    if (is_val_obj) {
        var val_obj = val as DynObject;
        var val_obj_toString = val_obj.toString as clos(env, any) -> any; // TODO: change this back to clos(env, any) -> any
        var val_res = val_obj_toString!(val);
        return val_res;
    } else { } // TODO: can't put `return val;` in here. WHY NOT??????
    return val;
}

/// The JavaScript `+` operator. This isn't implemented to spec:
/// https://www.ecma-international.org/ecma-262/5.1/#sec-11.6.1
/// because it doesn't first try to coerce its arguments to primitives.
/// It instead uses a simple trick to emulate most of the behavior in the spec:
/// if either of the arguments are NotWasm ptrs, both will be coerced into
/// strings, and string concatenation will happen instead. If both of the
/// arguments are NOT pointers, then they're both primitives and
/// the user is expecting mathematical plus.
function jnks_plus(left: any, right: any): any {
    // load cached function into a local variable because notwasm doesn't
    // support directly calling functions stored in global variables.
    var plus = jnks_primitive_plus;
    // Convert non-primitive values to primitives
    left = to_primitive(left);
    right = to_primitive(right);

    var result = plus(left, right);
    return result;
}
