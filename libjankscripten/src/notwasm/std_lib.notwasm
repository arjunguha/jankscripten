// Lazily-initialized global variables. DO NOT READ FROM THESE UNTIL THEY HAVE
// BEEN WRITTEN TO.
var Object: DynObject;
var Math: DynObject;
var global: DynObject;
var console: DynObject;
var __JNKS: DynObject;
// (_, _this, what) -> i32 or f64(NaN)
var parseInt: clos(env, any, any) -> any;
// temporary Error ground to see other compile-time errors (unrelated to this
// being called Error)
var Error: clos(env, any, any) -> any;
// REAL one:
// var Error: clos(env, any, str) -> DynObject;

// Other cached runtime functions
var jnks_any_is_object: (any) -> bool;
var jnks_primitive_plus: (any, any) -> any;

// Initialize JankScripten runtime.
function jnks_init_std_lib(): i32 {

    // Create the Object class. This means creating a (really) empty object,
    // giving it a prototype, and assigning its static methods, such as
    // Object.create.
    // 
    // Once the default Object class is set up, object literals like `{}` can
    // be used.

    // create the actual object for Object
    var nullVar = null;
    var objectClass = jnks_objectCreate!(undefined, nullVar);
    Object = objectClass as DynObject;

    // set a completely empty prototype.
    // it's called objectPrototypeAny because its type is any.
    var objectPrototypeAny = jnks_objectCreate!(undefined, nullVar);
    Object.prototype = objectPrototypeAny;

    // assign static methods to Object
    Object.create = any(jnks_objectCreate);

    // Cache Object properties for jnks_new_object
    jnks_objectPrototype = objectPrototypeAny;

    // assign methods to Object.prototype.
    // first, unwrap objectPrototypeAny into a DynObject
    var objectPrototype = objectPrototypeAny as DynObject;
    var objectToStringF = jnks_Object_prototype_toString;
    var objectToString = clos(objectToStringF, );
    objectPrototype.toString = any(objectToString);

    Math = {};
    var mathSqrtF = rt(math_sqrt);
    var mathSqrt = clos(mathSqrtF, );
    Math.sqrt = any(mathSqrt);
    var mathSinF = rt(math_sin);
    var mathSin = clos(mathSinF, );
    Math.sin = any(mathSin);
    var mathAbsF = rt(math_abs);
    var mathAbs = clos(mathAbsF, );
    Math.abs = any(mathAbs);
    var mathMinF = rt(math_min);
    var mathMin = clos(mathMinF, );
    Math.min = any(mathMin);
    var mathMaxF = rt(math_max);
    var mathMax = clos(mathMaxF, );
    Math.max = any(mathMax);
    // source: firefox console -> Math.PI
    Math.PI = any(3.141592653589793f);

    // __JNKS
    __JNKS = {};
    var heapDumpF = rt(heap_dump);
    var heapDump = clos(heapDumpF, );
    __JNKS.heap_dump = any(heapDump);
    var run_gc_f = rt(run_gc);
    var run_gc = clos(run_gc_f, );
    __JNKS.run_gc = any(run_gc);
    var mem_info_f = rt(mem_info);
    var mem_info = clos(mem_info_f, );
    __JNKS.mem_info = any(mem_info);

    // Other cached runtime functions
    var primitive_plusF = rt(janky_primitive_plus);
    // var primitive_plus = clos(primitive_plusF, );
    jnks_primitive_plus = primitive_plusF;
    var any_is_objectF = rt(any_is_object);
    // var any_is_object = clos(any_is_objectF, );
    jnks_any_is_object = any_is_objectF;

    console = {};
    var consoleLogF = rt(console_log);
    var consoleLog = clos(consoleLogF, );
    console.log = any(consoleLog);
    console.info = any(consoleLog);

    // === free-floating stuff in the global namespace ===

    var parseIntF = rt(parse_int);
    parseInt = clos(parseIntF, );

    Error = clos(error_ground, );

    // Now that the default Object class has been set up, create the global 
    // object.
    global = {};

    // notwasm limitation
    return 0;

}

function error_raw(_: env, _this: any, message: str): DynObject {
    // `Error("err")` has same functionality as `new Error("err")`
    // so Error i guess doesn't use `this`
    var e_proto = {};
    e_proto.name = any("Error");
    e_proto.message = any(message);
    var e_proto_any = any(e_proto);
    var e = jnks_objectCreate!(undefined, e_proto_any);
    return e as DynObject;
}

// there's no reason Error has to be ground. it's top-level, not stored
// in an object, so it's never boxed into any. however, coercion_insertion
// wants to convert it to an object because i'm still waiting to add Mark's
// function-objects, so it needs to be any'd to create a bad coercion so i
// can see other compile-time errors
function error_ground(dummyEnv: env, this: any, message: any): any {
    var messageStr = message as str;
    var result = error_raw(dummyEnv, this, messageStr);
    return any(result);
}

// The default implementation of `Object.prototype.toString`.
// All objects that don't specifically override `toString` will
// have this implementation.
function jnks_Object_prototype_toString(_: env, this: any): any {
    return any("[object Object]");
}

// Converts the given value into a primitive value.
// This really just amounts to calling `toString` if the value
// is an object.
// This isn't implemented to spec but should have the same behavior
// unless you're doing some funky stuff with objects:
// https://www.ecma-international.org/ecma-262/5.1/#sec-9.1
function to_primitive(val: any): any {
    // load cached function into a local variable because notwasm doesn't
    // support directly calling functions stored in global variables.
    var is_object = jnks_any_is_object;
    var is_val_obj = is_object(val);
    if (is_val_obj) {
        var val_obj = val as DynObject;
        var val_obj_toString = val_obj.toString as clos(env, any) -> any;
        var val_res = val_obj_toString!(val);
        return val_res;
    } else { }
    return val;
}

/// The JavaScript `+` operator. This isn't implemented to spec:
/// https://www.ecma-international.org/ecma-262/5.1/#sec-11.6.1
/// because it doesn't first try to coerce its arguments to primitives.
/// It instead uses a simple trick to emulate most of the behavior in the spec:
/// if either of the arguments are NotWasm ptrs, both will be coerced into
/// strings, and string concatenation will happen instead. If both of the
/// arguments are NOT pointers, then they're both primitives and
/// the user is expecting mathematical plus.
function jnks_plus(left: any, right: any): any {
    // load cached function into a local variable because notwasm doesn't
    // support directly calling functions stored in global variables.
    var plus = jnks_primitive_plus;
    // Convert non-primitive values to primitives
    left = to_primitive(left);
    right = to_primitive(right);

    var result = plus(left, right);
    return result;
}
